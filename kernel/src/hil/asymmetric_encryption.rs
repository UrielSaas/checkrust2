//! Interface for asymmetric-cipher encryption

use crate::hil::entropy;
use crate::ErrorCode;

/// Upcall from the `PubPrivKey` trait.
pub trait PubPrivKeyClient<'a> {
    /// The `generate()` command has been completed.
    fn generation_complete(&'a self, result: Result<(), ErrorCode>);
}

/// An internal representation of a asymetric Public and/or Private key.
///
/// This trait is useful for managing keys internally in Tock.
pub trait PubPrivKey<'a> {
    /// Set the client. This client will be called when the `generate()`
    /// function is complete. If using an existing key this doesn't need to be
    /// used.
    fn set_client(&'a self, client: &'a dyn PubPrivKeyClient<'a>);

    /// This generates a new private/public key pair of `length` bits.
    /// This will call the `generation_complete()` on completion. They keys
    /// cannot be used and will return `None` until the upcall has been called.
    ///
    /// The keys generated by `generate()` will depend on the implementation.
    fn generate(&'a self, trng: &'a dyn entropy::Entropy32, length: usize)
        -> Result<(), ErrorCode>;

    /// Import an existing public key. This will override any existing keys.
    fn import_public_key(&mut self, public_key: &[u8]) -> Result<(), ErrorCode>;

    /// Import an existing private key. This will override any existing keys.
    fn import_private_key(&mut self, private_key: &[u8]) -> Result<(), ErrorCode>;

    /// Return the public key if it exists.
    fn pub_key(&'a self) -> Option<&'a [u8]>;

    /// Return the private key if it exists.
    fn priv_key(&'a self) -> Option<&'a [u8]>;
}

/// The crypto buffers
/// encrypt -> Source, destination and key.
/// verify -> Message, signature and key.
/// decrypt -> Source, destination and key.
/// Sign -> Input, destination and key.
pub struct CryptoBuffers {
    /// `encrypt()` -> Source
    /// `verify()` -> Message
    /// `decrypt()` -> Source
    /// `sign()` -> Input
    pub source: &'static mut [u8],
    /// `encrypt()` -> Destination
    /// `verify()` -> Signature
    /// `decrypt()` -> Destination
    /// `sign()` -> Destination
    pub dest: &'static mut [u8],
    pub key: &'static mut dyn PubPrivKey<'static>,
}

pub enum Operation {
    Encrypt,
    Decrypt,
    Sign,
    Verify,
}

/// Upcall from the `AsymCrypto` trait.
pub trait AsymClient<'a> {
    /// The `encrypt()`/`decrypt()`/`sign()` command has been completed.
    ///
    /// On success the value of `result` should be ignored unless the `op`
    /// was a `Operation::Verify` in which cast this indicates if the message
    /// is valid.
    fn operation_done(
        &'a self,
        result: Result<bool, ErrorCode>,
        op: Operation,
        buffers: CryptoBuffers,
    );
}

pub trait AsymCrypto<'a> {
    /// Set the `AsymClient` client to be called on completion.
    fn set_client(&'a self, client: &'a dyn AsymClient<'a>);

    /// Encrypt the data in the `source` destination with the public `key`
    /// specified and store the data in the `dest` buffer.
    ///
    /// On completion the `operation_done()` upcall will be scheduled.
    /// The type of encryption that occurs will be based on the latest
    /// `set_mode*()` function that was called.
    fn encrypt(&self, buffers: CryptoBuffers) -> Result<(), (ErrorCode, CryptoBuffers)>;

    /// Verify the data in the `source` destination with the public `key`
    /// specified.
    ///
    /// On completion the `operation_done()` upcall will be scheduled.
    /// The type of verification that occurs will be based on the latest
    /// `set_mode*()` function that was called.
    fn verify(&self, buffers: CryptoBuffers) -> Result<(), (ErrorCode, CryptoBuffers)>;

    /// Decrypt the data in the `source` destination with the private `key`
    /// specified and store the data in the `dest` buffer.
    ///
    /// On completion the `operation_done()` upcall will be scheduled.
    /// The type of decryption that occurs will be based on the latest
    /// `set_mode*()` function that was called.
    fn decrypt(&self, buffers: CryptoBuffers) -> Result<(), (ErrorCode, CryptoBuffers)>;

    /// Sign the data in the `source` destination with the private `key`
    /// specified and store the data in the `dest` buffer.
    ///
    /// On completion the `operation_done()` upcall will be scheduled.
    /// The type of operation that occurs will be based on the latest
    /// `set_mode*()` function that was called.
    fn sign(&self, buffers: CryptoBuffers) -> Result<(), (ErrorCode, CryptoBuffers)>;

    /// Clear any confidential data.
    fn clear_data(&self);
}

/// Support for RSA PKCS1v15.
pub trait RSAPKCS1v15 {
    /// Set the Asymetric Crypto mode to RSA PKCS1v15.
    fn set_mode_rsa_pkcs1v15(&self) -> Result<(), ErrorCode>;
}

/// Support for ECC NIST P-256.
pub trait ECCP256 {
    /// Set the Asymetric Crypto mode to ECC NIST P-256.
    fn set_mode_ecc_p256(&self) -> Result<(), ErrorCode>;
}
