//! Interface for Public/Private key encryption

use crate::hil::entropy;
use crate::ErrorCode;

/// Upcall from the `PubPrivKey` trait.
pub trait PubPrivKeyClient<'a> {
    /// The `generate()` command has been completed.
    fn generation_complete(&'a self, result: Result<(), ErrorCode>);
}

/// An internal representation of a asymetric Public and/or Private key.
///
/// This trait is useful for managing keys internally in Tock.
pub trait PubPrivKey<'a> {
    /// Set the client. This client will be called when the `generate()`
    /// function is complete. If using an existing key this doesn't need to be
    /// used.
    fn set_client(&'a self, client: &'a dyn PubPrivKeyClient<'a>);

    /// This generates a new private/public key pair of `length` bits.
    /// This will call the `generation_complete()` on completion. They keys
    /// cannot be used and will return `None` until the upcall has been called.
    ///
    /// The keys generated by `generate()` will depend on the implementation.
    ///
    /// The possible ErrorCodes are:
    ///     - `BUSY`: The underlying `trng` is busy.
    ///     - `ALREADY`: A key is already imported or in the process of being
    ///                  generated.
    ///     - `OFF`: The underlying `trng` is powered down.
    ///     - `INVAL`: An invalid length was supplied
    ///     - `NOMEM`: The key can not be stored.
    fn generate(&'a self, trng: &'a dyn entropy::Entropy32, length: usize)
        -> Result<(), ErrorCode>;

    /// Import an existing public key. This will override any existing keys.
    ///
    /// The possible ErrorCodes are:
    ///     - `ALREADY`: A key is already imported or in the process of being
    ///                  generated.
    ///     - `INVAL`: An invalid key was supplied.
    ///     - `NOMEM`: The key can not be stored.
    fn import_public_key(&mut self, public_key: &[u8]) -> Result<(), ErrorCode>;

    /// Import an existing private key. This will override any existing keys.
    ///
    /// The possible ErrorCodes are:
    ///     - `ALREADY`: A key is already imported or in the process of being
    ///                  generated.
    ///     - `INVAL`: An invalid key was supplied.
    ///     - `NOMEM`: The key can not be stored.
    fn import_private_key(&mut self, private_key: &[u8]) -> Result<(), ErrorCode>;

    /// Store the public key in buffer if it exists.
    fn pub_key(&'a self, buffer: &mut [u8]) -> Option<()>;

    /// Store the private key in buffer if it exists.
    fn priv_key(&'a self, buffer: &mut [u8]) -> Option<()>;
}

pub enum Operation {
    Encrypt,
    Decrypt,
    Sign,
    Verify,
}

/// Upcall from the `RsaCrypto` trait.
pub trait Client<'a, B> {
    /// The `encrypt()`/`decrypt()`/`sign()` command has been completed.
    ///
    /// On success the value of `result` should be ignored unless the `op`
    /// was a `Operation::Verify` in which cast this indicates if the message
    /// is valid.
    fn operation_done(&'a self, result: Result<bool, ErrorCode>, op: Operation, buffers: B);
}

/// The RSA specific crypto buffers
/// encrypt -> Source, destination and key.
/// verify -> Message, signature and key.
/// decrypt -> Source, destination and key.
/// Sign -> Input, destination and key.
pub struct RsaCryptoBuffers {
    /// `encrypt()` -> Source
    /// `verify()` -> Message
    /// `decrypt()` -> Source
    /// `sign()` -> Input
    pub source: &'static mut [u8],
    /// `encrypt()` -> Destination
    /// `verify()` -> Signature
    /// `decrypt()` -> Destination
    /// `sign()` -> Destination
    pub dest: &'static mut [u8],
    pub key: &'static mut dyn RsaKey<'static>,
}

pub trait RsaKey<'a>: PubPrivKey<'a> {
    /// Returns the modulus of the key pair if it exists
    fn modulus(&'a self) -> Option<&'a [u8]>;

    /// Returns the public exponent of the key pair if it exists
    fn public_exponent(&'a self) -> Option<u32>;

    /// Returns the private exponent of the key pair if it exists
    fn private_exponent(&'a self) -> Option<&'a [u8]>;
}

pub trait RsaCryptoBase<'a> {
    /// Set the `Client` client to be called on completion.
    fn set_client(&'a self, client: &'a dyn Client<'a, RsaCryptoBuffers>);

    /// Clear any confidential data.
    fn clear_data(&self);
}

pub trait RsaCryptoCrypt<'a> {
    /// Encrypt the data in the `source` destination with the public `key`
    /// specified and store the data in the `dest` buffer.
    ///
    /// On completion the `operation_done()` upcall will be scheduled.
    /// The type of encryption that occurs will be based on the latest
    /// `set_mode*()` function that was called.
    fn encrypt(&self, buffers: RsaCryptoBuffers) -> Result<(), (ErrorCode, RsaCryptoBuffers)>;

    /// Decrypt the data in the `source` destination with the private `key`
    /// specified and store the data in the `dest` buffer.
    ///
    /// On completion the `operation_done()` upcall will be scheduled.
    /// The type of decryption that occurs will be based on the latest
    /// `set_mode*()` function that was called.
    fn decrypt(&self, buffers: RsaCryptoBuffers) -> Result<(), (ErrorCode, RsaCryptoBuffers)>;
}

pub trait RsaCryptoSign<'a> {
    /// Verify the data in the `source` destination with the public `key`
    /// specified.
    ///
    /// On completion the `operation_done()` upcall will be scheduled.
    /// The type of verification that occurs will be based on the latest
    /// `set_mode*()` function that was called.
    fn verify(&self, buffers: RsaCryptoBuffers) -> Result<(), (ErrorCode, RsaCryptoBuffers)>;

    /// Sign the data in the `source` destination with the private `key`
    /// specified and store the data in the `dest` buffer.
    ///
    /// On completion the `operation_done()` upcall will be scheduled.
    /// The type of operation that occurs will be based on the latest
    /// `set_mode*()` function that was called.
    fn sign(&self, buffers: RsaCryptoBuffers) -> Result<(), (ErrorCode, RsaCryptoBuffers)>;
}

pub trait RsaCrypto<'a>: RsaCryptoBase<'a> + RsaCryptoCrypt<'a> + RsaCryptoSign<'a> {}

impl<'a, T: RsaCryptoBase<'a> + RsaCryptoCrypt<'a> + RsaCryptoSign<'a>> RsaCrypto<'a> for T {}

/// Support for RSA PKCS1v15.
pub trait RSAPKCS1v15 {
    /// Set the Asymetric Crypto mode to RSA PKCS1v15.
    fn set_mode_rsa_pkcs1v15(&self) -> Result<(), ErrorCode>;
}
